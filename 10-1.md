# **（所有链接仅供参考，为后续完善）**

# **Java基础**



## **多线程**AAAAAAAAAAAAA

### **1.创建多少线程合适**？【 参考链接：https://mp.weixin.qq.com/s?biz=Mzg5MzU2NDgyNw==&mid=2247487130&idx=1&sn=267e8f02170eaa7a4eb5d30f4ab6f72a&source=41#wechat_redirect】

- #### **分两种情况**：

  1. **CPU密集型程序（CPU计算多）**

     1. ##### CPU密集型程序程序需要CPU进行计算，程序运行中线程占用cpu时间较长

        **多核情况**：可以每个线程尽可能的分配一个cpu来运行任务会减少时间分片，线程切换

        **单核情况**：一个cpu运算多个线程任务会进行 时间分片线程上下文切换

     **总结：CPU密集型程序多核的情况多线程编程可以最大化利用系统资源**

     ```text
     业内结论：创建的线程数最好为CPU逻辑核心数+1
     （多出一条线程为了防止一些特殊情况导致线程发生页错误或暂停，保证任务执行不终止）
     ```

  2. **IO密集型程序（线程IO操作占用时间多）**

     1. 线程IO操作cpu会空闲下来，此时空闲cpu可以去执行其他线程任务

     ```
     业内结论：IO密集型程序创建线程数业内（CPU利用率=IO耗时/CPU耗时）最佳线程数 = CPU核心数 *  (1/CPU利用率) =  CPU核心数 * 1 + (IO耗时/CPU耗时)
     ```

     1. **IO密集型程序 如果实在不清楚cpu，io耗时数据，创建线程数可以为核心线程数的两倍**

     

     ```
     我怎么知道具体的 I/O耗时和CPU耗时呢？
     怎么查看CPU利用率？
     
     可以根据服务链路追踪工具查看资源耗时：
     SkyWalking
     CAT
     zipkin
     
     ```

最后：**CPU核心数并不一定能代表程序的运行性能，**因为程序在临界区运行时（如加锁区域）是串行的，需要根据实际运用技术加上良好的编程习惯进行优化

**阿姆达尔定律公式：**

```text
S = 1/[(1-p)+(p/n)] 
n:cup核数，
p:程序并行百分比，
1-p:程序串行百分比

比如如果我们的代码串行率为5%,带入公式S结果为20，这个场景结果表明再如何优化，性能最高无限接近20倍
```

### ThreadLocal(线程变量副本  简易参考   待补充~)

- Synchronized实现内存共享，ThreadLocal为每个线程维护一个本地变量。
  采用空间换时间，它用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。
  ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本。

- ThreadLocal在Spring中发挥着巨大的作用，在管理Request作用域中的Bean、事务管理、任务调度、AOP等模块都出现了它的身影。
  Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的Bean就能够以singleton的方式在多线程中正常工作了。

  ```text
  注：threadlocal线程泄露问题根源分析在线程生命周（threadlocal生命周期同线程的生命周期）入手，详细待补充~
  ```



### Q&A : 能说说线程池的原理吗？(待补充~)

### 【线程池原理参考：https://mp.weixin.qq.com/s/NDOx94yY06OnHjrYq2lVYw、

### https://mp.weixin.qq.com/s/TQGtNpPiTypeKd5kUnfxEw、https://www.yuanjava.cn/posts/threadpool/】

类似一个生产工厂：

- 有订单：类似我们创建的线程		

- 工厂：类似我们的线程池

  - newSingleThreadPool:单例线程池，串行执行
  - newFixedThreadPool:定长线程池
  - newCachedThreadPool:缓存线程池，可动态调整 60秒回收一次
  - newScheduledThreadPool:可以定时任务，大小的无限线程池
  - newSingleThreadScheduledExecutor()：单例，可定时的线程池（框架中的心跳检测）
  - newWorkStealingPool:新增

  

  

- 正式员工：就是核心线程（corePoolSize）

- 临时员工：类似最大的线程（maxmumPoolSize）

- 仓库：就是阻塞队列

  - ArrayBlockingQueue：数组结构有界队列
  - LinkedBlockQueue:链表结构有界（不过默认是Integer.MAX_VALUE）队列(Executors常用)
  - SynchronousQueue：不存储元素阻塞队列（Executors常用）	
  - PriorityBlockingQueue:支持优先级排序的无界阻塞队列
  - LinkedTransferQueue:链表结构无界阻塞队列
  - LinkedBlockingDeque:链表双向阻塞队列

- 订单多了就要考虑利润，就有了拒绝策略

  - Aboutpolicy:丢任务抛异常
  - CallerRunsPolicy：由主线程（就是调用者所在的线程）执行被抛弃的任务,主线程处理完，在考虑队列中的任务！
  - DiscardOldestPolicy：丢弃队列中等待最久的任务，执行最新的任务
  - DiscardPolicy：丢任务不抛异常

### Q&A: 使用Executors静态创建线程池有什么缺点？阿里为什么提倡使用ThreadPoolExecutor创建？

答：

- Executors.newFixedThreadPool
  - 缺点：该线程池使用的阻塞队列是LinkedBlockingQueue：链表阻塞队列，默认容量为Integer.MAX_VALUE，容量过大，可能会堆积大量的任务，从而造成OOM(内存溢出)
- Executors.newSingleThreadExecutor
  - 缺点：该线程池使用的阻塞队列是LinkedBlockingQueue：链表阻塞队列，默认容量为Integer.MAX_VALUE，容量过大，可能会堆积大量的任务，从而造成OOM(内存溢出)
- Executors.newCachedThreadPool
  - 作用：该方法返回一个可根据实际需求调整线程数量的线程池。如果提交的任务没有空闲的线程处理，就会创建新的线程去处理该任务。如果有线程空闲时间超过60秒，就会被销毁
  - 缺点：该线程池允许创建的最大线程数量为Integer.MAX_VALUE，可能会创建出大量线程，导致OOM(内存溢出)
- Executors.newScheduleThreadPool
  - 作用：该方法可以创建自定义核心线程容量的线程池，而且该线程池支持定时以及周期性的任务执行。
- 缺点：
  - 该线程池允许创建的最大线程数量为Integer.MAX_VALUE，可能会创建出大量线程，导致OOM(内存溢出)

### QA 线程池拒绝策略

答:https://www.cnblogs.com/eric-fang/p/11584142.html -

> 　　线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize - 最大线程数
> 　　　总结起来，也就是一句话，当提交的任务数大于（workQueue.size() + maximumPoolSize ），就会触发线程池的拒绝策略。

> Aboutpolicy:丢任务抛异常
> 		CallerRunsPolicy：由主线程（就是调用者所在的线程）执行要被抛弃的任务,主线程处理完，在考虑队列中的任务！
> 		DiscardOldestPolicy：丢弃队列中等待最久的任务，执行最新的任务
> 		DiscardPolicy：丢任务不抛异常

### **线程池的执行机制  **（机制可以按需求修改—— 参考https://blog.csdn.net/Mr_25kjiang/article/details/105815054   链接中有提 dubb0 干了这事）

- 如果此时线程数小于核心线程数，那么就会新起一个线程来执行当前的任务。
- 如果此时线程数大于核心线程数，那么就会将任务塞入阻塞队列中，等待被执行。
- 如果阻塞队列满了，并且此时线程数小于最大线程数，那么会创建新线程来执行当前任务。
- 如果阻塞队列满了，并且此时线程数大于最大线程数，那么会采取拒绝策略。

## 

## **集合容器**

### 集合框架图

![集合容器框架图](image-source\collection_20221124152955.png)

### [Java集合](https://so.csdn.net/so/search?q=Java集合&spm=1001.2101.3001.7020)体系框架总结：【https://blog.csdn.net/m0_67322837/article/details/124322953】



### Hashset底层源码分析【https://www.jianshu.com/p/6cab0fae2403！】

底层Hashmap, key作为添加的值，value全部是persent

### **集合全解**

（掘金小伙）https://juejin.cn/post/6844904105891069965

https://www.jianshu.com/p/0b23cc00cca6/

### 补充【equals、==、intern () 之间的区别 https://my.oschina.net/WEguo/blog/1538853】



### **Arraylist,LinkList时间复杂度问题**

**1. 头部插入（删除）、中部插入（删除）、尾部插入（删除）实验**(**一千万元素实验**)

https://blog.csdn.net/A_captain_608/article/details/127205351

#### 实验结果：

> (1). LinkedList和ArrayList在一千万个元素中随机查询，可以看到ArrayList相对LinkedList快很多。（ArrayList有下标）根据下标随机获取值时间复杂度为O(1)
>
> (2). 在尾部删除，ArrayList不需要移动元素，LinkedList只需要删除尾部指针，因此两者耗时相近。(O(1)级别时间复杂度)
>
> (3). 在尾部删除，ArrayList不需要移动元素，LinkedList只需要删除尾部指针，因此两者耗时相近。(O(1)级别时间复杂度)
>
> (4).头部插入与头部删除一样，ArrayList同样需要移动近一千万的元素，而LinkedList只需要删除头部的指针即可。LinkedList比ArrayList快。
>
> **(5).在中部插入与删除类似，LinkedList的遍历速度没有ArrayList移动元素的速度快。ArrayList比LinkedList快。** 
>
> （**多数场景-综合选型：要随机也就是根据下标来查询多的话就用ArrayList，插入的话，要是频繁插入多，就用LinkedList，涉及扩容的情况(在ArrayList任意位置插入或者删除元素时，就需要将后序元素整体往前或者往后搬移，时间复杂度为O(n)，效率比较低，因此ArrayList不适合做任意位置插入和删除比较多的场景，更别说涉及扩容机制耗时**）
>
> 扩容因子：（https://baijiahao.baidu.com/s?id=1742659763306352727&wfr=spider&for=pc）
>
> (6).尾部插入与尾部删除类似，LinkedList不需要遍历，ArrayList不需要移动元素，因此两者效率相近
>
> 

#### 总结：通过以上验证可知并不是所有的插入、删除，LinkedList都要比ArrayList快，要看数据量，要根据具体插入、删除的位置而定。 

### 严谨对比ArrayList与Linklist

https://blog.csdn.net/qq_61862008/article/details/127931780（此链接最后描述的扩容因子不详细，参考上面的连接）





### **ArrayList为什么移动元素的速度那么快？**

### 

### **ArrayList  与Linklist 访问速度**

ArrayList  访问速度快不单单因为其是内存连续的原因，它带下标还实现了 RandomAccess接口，它是一个标记接口，用以标记实现的List集合具备快速随机访问的能力。

当一个List拥有快速访问功能时，其遍历方法采用for循环最快速。而没有快速访问功能的List，遍历的时候采用Iterator迭代器最快速。

当我们不明确获取到的是Arraylist，还是LinkedList的时候，我们可以通过RandomAccess来判断其是否支持快速随机访问，若支持则采用for循环遍历，否则采用迭代器遍历

https://www.cnblogs.com/V1haoge/p/10755424.html (RandomAccess)



### Java反射原理，我刚好都会

https://blog.csdn.net/JAck_chen0309/article/details/105427350



### **Comparable与**Comparato的区别

https://www.cnblogs.com/stamp/p/java_base.html

JUC 之



## **设计模式**

### 动态代理：cgib、jdk、java javassist（待补充）

【实例参考：https://cloud.tencent.com/developer/article/1696016、

​						http://javahao123.com/?p=631】

**1、cglib：Code Generation library**  

- 基于ASM（java字节码操作码）的高性能代码生成包
- 被许多AOP框架使用
- 区别于JDK动态代理，cglib不需要实现接口	

**2、ASM：**（参考：https://jueee.github.io/2020/08/2020-08-27-Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%93%8D%E7%BA%B5%E6%A1%86%E6%9E%B6ASM/）ASM 是一个 Java 字节码操控框架（操纵级别：JVM汇编指令级别）。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，能够根据用户要求生成新类。ClassWriter接口 http://javahao123.com/?p=631

> **不过ASM在创建class字节码的过程中，操纵的级别是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解。**ASM是修改字节码的最底层方案了，可以直接生成、修改、保存二进制class文件，直接使用ASM非常困难，需要在理解汇编等知识的基础上，手撸字节码，不过大部分高级字节码生成工具都会依赖ASM，包括CGLIB、ByteBuddy等【https://zhuanlan.zhihu.com/p/448871215】

**3.javassist：它是一个开源的分析、编辑和创建Java字节码的类库 它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架  javassist是[jboss](https://link.jianshu.com/?t=http://baike.baidu.com/view/309533.htm)的一个子项目，其主要的优点，在于简单，而且快速   （性能高于反射，相比于 ASM 稍低）**

> **直接使用java编码方式，抽象出classpool对象 不像ASM需要需要了解底层虚拟机指令，javassist在asm上层一种封装，asm框架直接操作字节码，一般为其它动态代理模式如jdk、cjlib、Javassist做底层实现**

**4、JDK**  



**versus:**

ASM是面向字节码的，javassist是面向java api的。javassist对程序员更加友好，ASM效率更高。
jdk 生成的代理类字节码是基于 反射实现的，调用的是 invokehandler，而javassist和asm都是直接修改字节码，jdk，是在委托类基础上生成一个代理类，而javassist和asm可以直接修改原来的类,
javassist和asm快于jdk。

cglib主要对指定类生产一个子类覆盖其中非final方法，（cglib继承代理，final修饰无法代理修改) 获取其class文件读入内存，所有方法调用入口（皆在于invoke方法）cglig编译成class文件会会生成额为的fast-class文件,它记录了各个method的索引（类名+方法名+参数）通过计算索引快速定位要执行的方法，代理对象执行该方法，然后super调用父类（执行了被代理对象的方法）并且可以复用，后续直接被class对象执行，提高效率，因此cjlib生成类后后期执行快

Cglib比JDK快？

cglib底层是ASM字节码生成框架，但是字节码技术生成代理类，在JDL1.6之前比使用java反射的效率要高
在jdk6之后逐步对JDK动态代理进行了优化，在调用次数比较少时效率高于cglib代理效率

只有在大量调用的时候cglib的效率高，但是cglib停止不前，jdk每次升级版本，jdk代理就会优化，
在1.8的时候JDK的效率已高于cglib

Cglib不能对声明final的方法进行代理，因为cglib是动态生成代理对象，final关键字修饰的类不可变只能被引用不能被修改

【https://www.cnblogs.com/brithToSpring/p/13356626.html、https://www.jianshu.com/p/eea9a3acbaad】



### **装饰器模式与类继承增强  区别（https://bit.ly/3Q3fO5k）**

- 装饰每个功能类增加不相耦合，灵活扩减，功能类间相组合太多易造成问题排查困难
- 继承增强因单一继承限制，每个功能节点间呈串联形态（当前功能节点叠加之前所需功能），增强功能类数量决定功能体系是否臃肿

### **装饰器模式和代理模式  区别**【https://bit.ly/46A7saL】

- 代理是全权代理，目标根本不对外，全部由代理类来完成；装饰是增强，是辅助，目标仍然可以自行对外提供服务，装饰器只起增强作用。
- 装饰器模式强调的是：增强、新增行为；代理模式强调的是：对代理的对象施加控制，但不对对象本身的功能进行增强。
- 装饰器模式：生效的对象还是原本的对象；代理模式：生效的是新的对象（代理对象）

### **工厂模式**

- 工厂方法模式：对象与工厂分开，对象功能装配在对象上，一类对象交由一类工厂创建，类似装配模式组配特性，因每类对象皆需相应工厂来创建，易造成结构臃肿。
- 简单/静态工厂：修改工厂模板方法一类对象一类工厂特性，交由一个工厂创建，其内部有逻辑判断（根据传值）按需创建一类对象，因对象交由一个工厂创建，增减皆需修改工厂逻辑
- 抽象工厂：工厂方法成年版，一样一类对象一类工厂进行区分创建，以此为基础又细化抽象出每类对象特有属性，多维度定位创建
- 泛型工厂：只需一个工厂，泛型+反射，不用再一类对象一类工厂，工厂内部不用再进行逻辑判断创建那类对象

### **策略模式与装饰器，代理模式的区别**

- 策略模式：相比结构严谨，划分三层结构，1、接口 A，2、接口实现类 (A->)B、3、context上下文类 C，接口类为其成员，隔离具体实现类逻辑，须把实现类（A->）B 传入 （context） C类，由其（context）内部(A->）B类父类接口A类型成员，以多态特性去执行其子类（A->）B， **这里B类继承A接口，B可以直接执行方法逻辑，这样叫类继承多态，抽出一层context封装多态，整体成装饰器结构，其把实现类具体逻辑隔离开**，更符合面向对象编程

### **责任链模式：**    

​	为不同处理逻辑创建handle类，不同逻辑handle类串联成一条逻辑处理链、**handle为类方法函数，故执行机制类似递归**，请求从责任链首位节点handle到尾部节点handle，之后逆向执行到首位handle处响应处理结果

# **mabits**

## 说下mabits 源码:

答：
运行原理：
	1.基于java的持久层框架，起初名字叫iBatis后来改为Mibats,他和hibernate区别在于
	hibernate不用提供sql它根据配置的映射文件文件自动生产sql，而mybatis是要自己提供sql的，比较灵活

- 1,构建SqlSessionFactory,先通过SqlSessionFactoryBuilder去构建，需要BaseBuilder子类XmlConfigBuilder解析配置XML文件，读取配置参数（typeHander对象），
  XmlConfigBuilder通过typeHanderElement()方法解析typeHanders,配置的typehander都会被注册到typeHanderRegistry对象里，它是configuration单例的一个属性,configuration可以通过它拿到typehander对象 这一步是吧参数放到configuration里
- 2.接下来就是sqlsession了 它操作数据库，通过执行器Executor调度statementHander来运行，他也是根据configuration来构建，然后通过使用prepareStatement方法里调用statementHander的prepare对sql编译，初始化，在通过statementHander的parameterrize来设置参数，最后使用statementHander的query方法把ResultHandler封装的结果返回调用者！

【XmlConfigBuilder解析xml将sql和对应配置 通过MapperStatement（保存一个映射节点内容，映射的SQL语句id,参数等信息）,sqlSource（提供boundSql的对象 MapperStatement的属性）,BoundSql（结果对象）保存起来 此时configuration就可以构建成SqlSessionFactory了】

所以它的生命周期也是 sqlSessionFactiryBuilder——》sqlSessionFactory--》sqlSession--》mapper

## 问： Dao的工作原理是？



  https://www.cnblogs.com/qmillet/p/12523636.html
	答：
	Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。



## **问：说下mabits一级缓存二级缓存！**

（1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。

（2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；

（3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear 掉并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。

## 问 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？

答：mybatis支持延迟加载比如一对多的情况下，配置lazyLoadingEnabled=true|false。

它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。

当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。

# **数据库**

## 一、数据库char类型索引失效（索引失效）

https://blog.csdn.net/zhao_zi_ming_lc/article/details/105478162

https://zhuanlan.zhihu.com/p/467688761（知乎参考资料）

1.索引列值为null，此时会索引失效

2.sql的语句中写了or ，如果or后的字段不全是带索引字段，此时索引失效。

3.模糊查询是 like 以 “%XX”开头，就是说左模糊不太行，右模糊可以。

**4.存在类型转换 ，比如你的索引字段是varchar型，但是你搜索条件却是 userid=333，字符需要加上引号  否则索引不生效。**(**温馨提醒一下，查询字符字段时，用双引号`“`和单引号`'`都可以。**)

5.数据量极少时，Mysql不会使用索引，因为全表扫描速度更快。

6.where 条件中的索引运算涉及计算时，索引失效。

7.索引列不要使用函数.（**Count () 函数会走覆盖索引索引**）

8.使用 is null 或者 is not null会导致无法使用索引

9.使用in会导致无法使用索引查询

10.列对比

两个单独建了索引的列，用来做列对比时索引会失效。

11.主键字段中使用not in关键字查询数据范围，任然可以走索引。而普通索引字段使用了not in关键字查询数据范围，索引会失效。

```sql
explain select * from user
where id（主建）  not in (173,174,175,176); ->走索引

explain select * from user
where height（普通索引字段） not in (173,174,175,176); - 不走索引
```

12.**exists** 有时候使用`in`关键字时性能不好，这时就能用`exists`关键字优化sql了，该关键字能达到in关键字相同的效果：

```sql
explain select * from user  t1
where  exists (select 1 from user t2 where t2.height=173 and t1.id=t2.id)
```

13.**没加where或limit**

  如果order by语句中没有加where或limit关键字，该sql语句将不会走索引。

```sql
explain select * from user
order by code, name;
```

14.**不同的排序**

前面已经介绍过，如果order by后面有一个联合索引的多个字段，它们具有相同排序规则，那么会走索引。但如果它们有不同的排序规则呢？结果不走索引

```sql
explain select * from user
order by code asc,age desc limit 100;
```

## 二、数据库buffer pool

https://blog.csdn.net/devcloud/article/details/123788028

## 三、数据库高可用集群

https://blog.csdn.net/qq_35642036/article/details/123823264

## **四、mysql调优**

https://github.com/gzc426/Java-Interview/blob/master/MySQL%E4%BC%98%E5%8C%96%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.md （参考）

### 1.调优方式概括 (**简化版-sql调优性能分析三板斧**：https://blog.51cto.com/u_15246373/4921308)

> 1.代码层次优化（待总结）
>
> **业务层**
>
> - ​	redis运用 , 数据多级缓存
> - 事务拆分，避免大量操作一起直接操作数据库
>
> ​    
>
> **sql语句调优**
>
> - **sql-insert**编写如insert 一条语句多值插入效率高  （**并且按照主建顺序插入效率也会高  因为InnoDB类型的表是按照主键的顺序保存的**）
> - **order by**  两种排序方式:(第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，**所有不是通过索引直接返回排序结果的排序**
>   **都叫 FileSort 排序,** 第**二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高**。)
>
> 
>
> **注：了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件**
> **和Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order by 的字段都是升序，或者都是**
> **降序。否则肯定需要额外的操作，这样就会出现FileSort。**
>
> - **group by** 也会进行排序，它执行过程是数据排序后分组，不需要分组后排序可以在语句后加上**order by null**  可以避免**filesort**
> - **优化嵌套查询** : 创建临时表也会影响效率如下：
>
> ```mysql
> explain select * from t_user where id in (select user_id from user_role );(会有逻辑上建立临时表)
> 
> 与
> 
> explain select * from t_user u , user_role ur where u.id = ur.user_id;(连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的
> 查询工作。
> )
> ```
>
> - **优化OR条件**  对于包含OR的查询子句，如果要利用索引，**则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索**
>   **引； 如果没有索引，则应该考虑增加索引。**
>
> 
>
> **可以考虑用union代替or **如下：
>
> ```mysql
> explain select * from emp where id = 1 or age = 30;
> 
> 改为：
> explain select * from emp where id = 1 union select *  from emp where  age = 30;
> 
> ```
>
> **经过替换分析执行计划 中 type：**
>
> ​	**type 显示的是访问类型，**是较为重要的一个指标，结果值从好到坏依次是：**
>
> **system > const > eq_ref > ref > fulltext > ref_or_null > index_merge >**
> **unique_subquery > index_subquery > range > index > ALL**
>
> 
>
> **UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距**
> **UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快**
> **这两项的差距就说明了 UNION 要优于 OR 。**
>
> - **优化分页查询**：
>
> 
>
> ```mysql
> select * from table_name where limit 10000000 100000010 ;(要MySQL排序前100000010 记录，10000000 - 100000010 的记录，其他记录丢弃，查询排序的代价非
> 常大 )。
> 
> 优化思路一
> 在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。
> select * from table_name t , (select table_id from table_name where limit 10000000 100000010  ) t1 
> where t.id = t1.id (先取符合条件的数据主建，然后回表根据主建取回数据)
> 
> 2 优化思路二
> 该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。
> select * from table_name where table_id > 10000000  limit 10
> 
> 
> ```
>
> **1.select * from table_name t , (select table_id from table_name where limit 10000000 100000010  ) t1**
> **where t.id = t1.id**
>
> **2.**  **select * from table_name where table_id > 10000000  limit 10**
>
> 
>
> - **使用SQL提示**:
>
> 1. **USE INDEX**
>    在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他
>    可用的索引
>
> create index idx_seller_name on tb_seller(name)
>
> select * frrom  tb_seller  where name = 'xxx'
>
> 2. **IGNORE INDEX** 
>    如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。
>
> explain select * from tb_seller ignore index(idx_seller_name) where name = 'xxx';
>
> 
>
> 3. **FORCE INDEX**
>    为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。
>
> create index idx_seller_address on tb_seller(address);
>
> 
>
> 2.数据库优化分库分表
>
> 3.表字段优化
>
> 4.sql索引优化
>
> ​	优化步骤：
>
> - **查看SQL执行频率**： show [session|global] status  查看统计sql执行次数，（ **session”或者“global ”**  表示级别，session为统计当前链接执行 的sql  ， global代表数据库本次启动至当前）如：show status like 'Com-xxx';结果会显示Com_select , com_delete....等其增删改查的执行次数 
> - **慢查询分析 定位低效率执行****SQL** （**不过推荐与使用show processlist，和  show profiles （profiling变量只影响当前session）相结合）**（https://blog.csdn.net/qq_41721746/article/details/125224018）
>
> 
>
> ```sql
> 使用步骤
> 
> -- 查询慢查询的时间
> show VARIABLES like '%slow_query_log%';
> 查看参数： slow_query_log 是否开启
> 		 slow_query_log_file 存储位置
> 		 long_query_time  慢查询设置时间
> 		 mysql > set  long_query_time = 1 语句设置时间参数
> 
> -- 分析慢查询日志 ：
> 根据上一步 得到慢查询日志的位置，cd 过去 然后vim打开
> 里面记录了 超过long_query_time的语句
> 		 
> -- 开启慢查询日志
> set GLOBAL slow_query_log=1;
> 
> 
> 
> 
> ```
>
> **注：show processlist :（ slow_query_log 慢查询日志在查询结束以后才纪录），所以在应用反映执行效率出现问题的时候查询慢查询 日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否** **锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。** 
>
> 
>
> - **show processlist** ：show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否** **锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。** 
>
> ​        
>
> ```sql
> mysql >  show processlist*
> 
> 1） id列，用户登录mysql时，系统分配的"connection_id"，可以使用函数connection_id()查看
> 2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句
> 3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户
> 4） db列，显示这个进程目前连接的是哪个数据库
> 
> 5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接
> （connect）等
> 6） time列，显示这个状态持续的时间，单位是秒
> 7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一
> 个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态
> 才可以完成
> 8） info列，显示这个sql语句，是判断问题语句的一个重要依据
> ```
>
> 
>
> - **使用explan执行计划**分析执行语句,查看索引使用情况，索引优化
>
> ```sql
> explain select * from tb_item where id = 1;
> 
> id select 查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。
> 
> select_type
> 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）
> 
> PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等
> 
> table 输出结果集的表
> 
> type
> 表示表的连接类型，性能由好到差的连接类型为( system ---> const -----> eq_ref ------> ref
> -------> ref_or_null----> index_merge ---> index_subquery -----> range -----> index ------>
> all )
> possible_keys 表示查询时，可能使用的索引
> 
> key 表示实际使用的索引
> 
> key_len 索引字段的长度
> 
> rows 扫描行的数量
> 
> extra 执行情况的说明和描述
> 
> 
> ```
>
> ![](C:/A/%E6%96%B0%E5%BB%BA%20Markdown%20File.assets/explain_avg.png)
>
> **extra列为null  --意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引，Extra中为NULL。**
>
> **extra 为user index 代表使用了覆盖索引（索引字段指向实际data），不需要回表**
>
> - **查看当前会话有哪些**  show  profile  Mysql从5.0.37版本开始增加了对 show profifiles 和 show profifile 语句的支持,show profifiles 能够在做SQL优化时 
>
> **帮助我们了解时间都耗费到哪里去了**。 
>
> 通过 have_profifiling 参数，能够看到当前MySQL是否支持profifile  默认是关闭的，可以使用select  @hace_profiling查看是否打开  使用set  profiling = 1打开session级别的profileing  
>
> 
>
> ```sql
> 例：
> 
> 1.mysql> show profiles ；
> query_id(执行语句id)   duration(耗时)  query（语句） 
> 		1				1.000000       select *  from 表名 
> 		
> 
> 2.通过show profile for query query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间 
> 一般senddata会耗时最长，它代表着mysql线程的io磁盘操作
> 
> 3.在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等
> 明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间  show profile cpu for query query_id 
> 
> 
> 
> ```
>
> - **trace分析优化器执行计划**：MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。
>
> 
>
> 5.落盘优化**MRR**，如果是存储介质是机械硬盘，随机写会耗费大量的时间（机械硬盘随机写会械臂摆动寻道，对计算机来说这个时间耗时是非常长的） 设置mrr大致原理会把数据在内存中排序，然后顺序写入磁盘 
>
> MRR优化
> MRR优化的目的就是减少磁盘随机IO的产生，其查询优化过程大致如下：
>
> ​	1、先把通过二级索引取出的值缓存在缓冲区中。
> ​	2、再把这部分缓冲区中的数据按照ID进行排序。
> ​	3、然后再依次根据ID去聚集索引中获取整个数据行。
>
> 可以看出，只需要通过一次排序，就使得随机IO，变为顺序IO，使得数据访问更加高效。
>
> read_rnd_buffer_size(参数设置是每个session独占，不宜设置太大)控制了数据能放入缓冲区的大小，如果一次性不够放就会分多次完成
> ————————————————
> 原文链接：https://blog.csdn.net/CSDN_WYL2016/article/details/120500830
>
> 

### **explain--- extra**

**extra列为null  --意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引，Extra中为NULL。***

**extra 为user index 代表使用了覆盖索引（索引字段指向实际data），不需要回表**



## **六、MYSQL高频面试解析8条**

**https://www.modb.pro/db/38159**

### MySQL 高频面试题解析

### **第01期：一条 update 语句的生命历程**

### 第02期：当前读和快照读的区别

### 第03期：InnoDB 怎么做表空间迁移

### 第04期：RR 隔离级别下真的不会产生幻读吗

### 第05期：MVCC 怎么实现的

### 第06期：复制的演进历程

### 第07期：有哪些死锁场景

### 第08期：物理备份和逻辑备份的区别



# netty (推荐参考P9)

池化思想，单元组件

Reactor  反应堆  

acceptor 接        （处理单元池化单元）



单线程阻塞服用处理多任务，联想cpu上下文切换（一通百通）



# **JVM**

## **1、jvm之TLAB**

https://mp.weixin.qq.com/s/ru-Y9NO-3dBaS__hWmgAEA

- 1、JVM首选TLAB进行内存空间的分配；
- 2、TLAB占用整个eden区域的1%，这个值也可以通过参数自定义；
- 3、TLAB每个线程私有，类似ThreadLocal线程私有空间，不用加锁，解决线程安全问题

通过这个问题也可以推理出另外一个问题，**堆区在严格意义上说不是线程共享的**

## 2、【深入理解JVM】：类加载机制

https://blog.csdn.net/u011080472/article/details/51329315



# **web容器**

## tomcat

# **servlet**









# **图文系统**



## 

## 1、深入理解CPU上下文切换（图文）

​	答：https://mp.weixin.qq.com/s/KwmNzTdjMB-ljQ0ysEGalg

​	线程和进程最大的区别在于，线程是**任务调度**的基本单位，而进程是**资源获取**的基本单位。

## 2、CUP总线介绍（数据总线，地址总线，控制总线）

​	 答：https://blog.csdn.net/wangbuji/article/details/78855672

### **3、争议很大的问题，32位和64位4GB内存操作系统申请8GB内存空间分别会发生什么？**

https://mp.weixin.qq.com/s/LbtXW1NtG6VqEpsqqOL3Ig

### 4.[键盘敲入 A 字母时，操作系统期间发生了什么？（设备控制器，控制器寄存器，DMA , 中断，设备驱动器-为了频闭设备控制器的不同提供统一接口）

https://mp.weixin.qq.com/s/04BkLtnPBmmx6CtdQPXiRA



# 图文网络

## 1、硬核！30 张图解 HTTP 常见的面试题，

## UDP的TCP特性（**QUIC 协议** 可以实现类似 TCP 的可靠性传输）

 https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A

# 1.1、ttp、https、SSL、TLS的区别

​	1.1.1、https、SSL :http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html

https://www.cnblogs.com/windpoplar/p/11923818.html

SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。

TLS：(Transport LayerSecurity，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。

SSL是Netscape开发的专门用户保护Web通讯的，目前版本为3.0。最新版本的TLS 1.0是IETF(工程任务组)制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的。



## **1.2、图解 ECDHE 密钥交换算法**

https://blog.csdn.net/m0_50180963/article/details/113061162



## 1.3、几幅图，拿下 HTTPS （TLS 协议， RSA 握手，RSA缺陷--------->DH优化--------->ECDHE）

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247487650&idx=1&sn=dfee83f6773a589c775ccd6f40491289&chksm=f98e5408cef9dd1ed900a15c27f00c811a5587ffa59a90a69a73d1794800838b6fd4b061ff9f&scene=178&cur_album_id=1337204681134751744#rd

## 1.4、这 HTTPS，真滴牛逼！（详解DH 与 ECDHE--------->结合1.3、RAS协议对比）

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247487977&idx=1&sn=f7cf6cd6b9c2f77f50eaf0fa73a43da2&chksm=f98e5543cef9dc55609b06b4712237b5bcbcbca924585be940e17083aa2e715d5f3daa9fde8b&scene=178&cur_album_id=1337204681134751744#rd



## 1.4.1    https--------->  https应用层与TCP/UDP传输层之间  SSL/TLS )如何结合CA(数字证书认证机构)，证书链 来完成数据传出的安全性的

 https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247495977&idx=1&sn=be8be79c6a6783c4f6c3dd40f1da5b9a&chksm=f98db583cefa3c95199c84383b3f7ce896ca00509a3eeb1a7c3ad439a62a5208e306638f162d&scene=178&cur_album_id=1337204681134751744#rd

## 1.5、 字节二面，优化HTTPS手段 

https://mp.weixin.qq.com/s?S__biz=MzUxODAzNDg4NQ==&mid=2247488081&idx=1&sn=a285752b4b1516830ba1f549323d3580&chksm=f98e56fbcef9dfedcfe006a920722a52bd865f0c1211ba8449cc55b32a7de2df1ddd88a25fb7&scene=178&cur_album_id=1337204681134751744#rd





## 1.5.1、(验证) HTTPS三次TCP握手后，在进行TLS四次验证（client hello--------->server  hello --------->client  key exchange--------->change cipher spec） / 如何TCP与TLS同时进行？ TLS1.30会话恢复时 可以同，TCP,HTTP请求同时进行吗？



https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247496547&idx=1&sn=bb5f2e32d93692cbcf2a9342d8ea6809&chksm=f98db7c9cefa3edf85adff8f03fc6e784d716990e1e637c75940ed1520654f92a0ccc010496c&scene=178&cur_album_id=1337204681134751744#rd



## 1.6、HTTP/1.1  HTTP/2.0.  HTTP/3.0

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247488924&idx=1&sn=d871ce0de68733b4673343aa2f4050f2&chksm=f98e5136cef9d820247cc40aa387f9c8dafc4d21f871ebf6235b93a43f851404b9a6280e3280&scene=178&cur_album_id=1337204681134751744#rd



## 1.7、鹅厂问题，（一个tcp链接，没有打开keepalive，没有数据传输，突然一段服务宕机或一端进程crash会发生什么）



https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247494464&idx=1&sn=dbfea9f2251479c29e3f8c040d297d5e&chksm=f98dafeacefa26fcc0b00463d1c07302d89b52cbfd5abd468feb8ceb2e00ab8fd50be0e1f7b8&scene=178&cur_album_id=1337204681134751744#rd



## 1.8、TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247495501&idx=1&sn=750469b8e164c0845645e2c9b969ebb8&chksm=f98dabe7cefa22f1836555ca312e472dd22aef8b93e46dc9bc35adfd93fa1f8b5c78683a1505&scene=178&cur_album_id=1337204681134751744#rd

   

> **这两个密钥可以双向加解密的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。**
>
> **流程的不同，意味着目的也不相同：**
>
> **公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；**
>
> **私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。**





## 2、探究！一个数据包在网络中的心路历程

url解析--------->本地host查缓存DNS-------->查浏览器缓存DNS--------->路由器查缓存DNS--------->运营商出查DNS（这里可以自己处理接入指定DNS服务器，避免三大运营商截胡）--------->根DNS处查......

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247483989&idx=1&sn=7e2ed852770743d3955ef9d5561fcef3&chksm=f98e46ffcef9cfe98e6c753afac86125b0d5891ca5e63968b5f3a8da4905d14274088f40c34e&scene=178&cur_album_id=1337204681134751744#rd



## 3、我又变强了一点

## （**https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247498670&idx=1&sn=49b2fcee8fbfe0d959cd701077b3c437&chksm=f98dbf04cefa3612d0fb02943ac6ec1c3718e37dc2e0eb6f86ec2e338a4bbf4f2ba16268bf44&scene=178&cur_album_id=1337204681134751744#rd**）



- [一个 TCP 连接，一端发生宕机和进程挂掉有什么区别？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247494464&idx=1&sn=dbfea9f2251479c29e3f8c040d297d5e&scene=21#wechat_redirect)
- [TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247495501&idx=1&sn=750469b8e164c0845645e2c9b969ebb8&scene=21#wechat_redirect)
- [HTTPS 中 TLS 和 TCP 能同时握手吗？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247496547&idx=1&sn=bb5f2e32d93692cbcf2a9342d8ea6809&scene=21#wechat_redirect)
- [TCP 三次握手和四次挥手，期间失败了会怎么样？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247496848&idx=1&sn=a7bf29e43bf5b97c0022dcbc32e52412&scene=21#wechat_redirect)
- [TCP 在 FIN_WAIT_2 状态下，收到处理乱序的 FIN 报文，会如何处理？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247497659&idx=1&sn=cee6f31710bb821370aad96f52c28825&scene=21#wechat_redirect)
- [一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，处于 establish 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247498170&idx=1&sn=8016a3ae1c7453dfa38062d84af820a9&scene=21#wechat_redirect)



## 3.1 、四次挥手   

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247502380&idx=1&sn=7b82818a5fb6f1127d17f0ded550c4bd&chksm=f98d8e86cefa0790707ed27477f4392e93dbf848a32afde35c4092f4567c82c576e90e739cad&scene=178&cur_album_id=1337204681134751744#rd



## 3.2 如何在不杀掉进程前提，关闭一个 TCP 连接？

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247503199&idx=2&sn=be8b2910ec6649eb122e018676f58fc2&chksm=f98d89f5cefa00e3760892f187cddfa846a5566434caa9c1fb13c4bf37540d3c5e41d9dc30d3&scene=178&cur_album_id=1337204681134751744#rd



## 3.3 图解网络总结 (一次小总结  推)

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247504844&idx=1&sn=20965bf9e761399e1f1e5a47cc7c28ff&chksm=f98d9766cefa1e70829d76183c8c0f28221af2ad1a20d263001042f2d885a5c827b6a26f13e0&scene=178&cur_album_id=1337204681134751744#rd



## 3.4、了解tcp 可以参考下这篇（ 推）

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247506302&idx=1&sn=e4d9b85735c34435d8207cef80314657&chksm=f98d9dd4cefa14c2592d193f6d93ecd2c4fcf1ce5f7c58e68a8e7494005c4eed339c2ee62a68&scene=178&cur_album_id=1337204681134751744#rd



## 3.4.1、TCP的缺陷

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247511543&idx=1&sn=66802e4073ad4811a2f42e4c04a8b5b2&chksm=f98de95dcefa604b045cb88b07f7ae6ce0edd12b3d51a430614f21869e70e4bb0ff5a44443ff&scene=178&cur_album_id=1337204681134751744#rd





## 3.4.2、TCP灵魂拷问，一或二或三，握手丢失会发生什么，一或二或三或四挥手丢失会发生什么？



https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247519129&idx=1&sn=d8d1781d18962a4f43a2c2a44250f1cd&chksm=f98dcf33cefa4625d6e3131e9bc8fa5920aaa083d869c0839b70ae4644fd8a39541a70cb12fc&scene=178&cur_album_id=1337204681134751744#rd



## 3.4.3、TCP握手和挥手  序列号的变化

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247521749&idx=1&sn=568b0d68f657d01d7c59d9d74f45a05f&chksm=f98dd17fcefa58690cccfd74fe37d52b5380471a7a27d6a11e7849947e33beb536fee67a7b13&scene=178&cur_album_id=1337204681134751744#rd





## 3.5 、TCP/IP 网络模型四层版

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247507850&idx=2&sn=4745f91284a0c431b1bfc59b6cbfe8c3&chksm=f98d9b20cefa1236e6de85bb6f54816df38d69ae9a2cf417bc05a7ddf2d16e27bba91675472f&scene=178&cur_album_id=1337204681134751744#rd





## 3.6、为什么tcp不是两次握手？客户端收到服务段错误ACK为啥不直接丢弃？（会发送RST）

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247524869&idx=1&sn=44f28db0215d147c14d74ed53e8beffd&chksm=f98d26afcefaafb91674e9de6a0b54372a7a81c9dda82c8351452105b987b780033732b186ff&scene=178&cur_album_id=1337204681134751744#rd

 TCP 需要三次握手，首要原因是为了防止旧的重复连接初始化造成混乱

由客户端RST干掉服务器旧连接而不是客户端直接丢弃服务的错误ack  避免双方进入超时重传的场景（直接丢弃消息数据，双发会默认断开了联系）



# **大数据**



## 一、大数据运用之商业运用

http://www.cnitpm.com/pm/9064.html

## 二、**HBase**

https://zhuanlan.zhihu.com/p/145551967?utm_source=wechat_session

### 三、大数据架构设计参考

http://www.uml.org.cn/bigdata/202111181.asp?artid=24658







# **云服务**

## IaaS、PaaS、SaaS其区别简介：

​	https://baijiahao.baidu.com/s?id=1756615657231854902&wfr=spider&for=pc

https://zhuanlan.zhihu.com/p/357877662（对比参考选型）

​	IaaS-主机服务，云上就是一般就是虚拟的主机，操作系统，底层的基础配置都要自己搞定

​	PaaS-在IaaS的基础上，简化了IaaS的一部分操作，更近一步，底层的配置如系统不需要自己关心，商家给配置好，直接可以把软件程序部署上去运行对外提供服务

​	SaaS-在上面的基础更近一步，直接整套体系，不用关心服务建设，开发，直接使用完成的软件

# **0>-_-<0**

## **1、jvm内存模型与java线程内存模型的区别**？

https://blog.csdn.net/jiey0407/article/details/126728076

  答：JVM内存模型主要服务于java对象的创建，例如java堆存储对象的实例数据，数组元素，虚拟机栈存储一些局部变量数据，对象引用；动态链接，本地方法栈类似虚拟机栈不过它服务于native方法，其它还有程序计数器记录程序运行的位置，执行引擎向本地内存出入数据，

java线程内存模型侧重于程序运行，java团队为了java程序内存操作在不同的系统cpu及硬件环境下能有一样的效果由此抽象出java内存模型，其主要分为主存和工作内存，java程序在运行的时候会把数据从主存复制一份到工作内存中进行操作。主存中read、工作内存load，read到的数据，之后user到执行引擎，之后执行引擎assign到工作内存，之后是store，write到主存这样一个主要过程

**联系**：两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，数组对象的元素，而工作内存则对应于虚拟机栈中的部分区域。

java线程对变量的操作方式是拷贝主内存的变量值到自己的工作内存然后进行操作，操作后的值会同步刷新进主内存，java内存模型定义了线程内存间交互的规范

**java内存模型（线程内存**）：

(1.https://mp.weixin.qq.com/s/DnZElICmvVwt2-V8lmEo0w

2.https://mp.weixin.qq.com/s/uqVkA74v_WDeNKoj5M-A6A）



**CPU层面的 缓存一致性协议（MESI协议，其实协议有很多，只是举个大家都可能见过的）。MESI拆开英文是（Modified （修改状态）、Exclusive （独占状态）、Share（共享状态）、Invalid（无效状态））**这些状态在线程对共享变量操作前进行判断



### **2、（jvm内存模型）JVM方法区，堆和方法区是怎样的关系，方法区内部的结构又是怎样的？**

https://blog.csdn.net/wangkexiang21/article/details/124014726

### **2.1.（jvm内存模型-）JVM堆与方法区是怎样的关系？**

《java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做“非堆”。目的是与Java堆区区别开来，这是《java虚拟机规范》有意的说明，《java虚拟机规范》在实现上更支持将方法区从堆逻辑中划分出来成为一块独立的内存区，jd8更是将方法区从jvm内存中划分出来，成为本地内存的一部分，名“元空间”

https://blog.csdn.net/weixin_45525272/article/details/126374737

## 3.jvm  GC执行的时机（safepoint了解吗）ooPmap、safepoint 、safe region？

答：

​		jvm在进行gc之前一般需要GC ROOT可达性分析可回收对象，而在虚拟栈中储存的不仅仅有对象引用，方法区中的类、常量、上千兆的体积量，因此GC ROOT会进行全栈扫描，并且会暂停用户线程，这样一来非常耗时！HotSpot就采取空间换时间的方法，用OopMap来储存栈上的对象引用的信息,在jvm中，一个线程为一个栈，一个栈由多个栈帧组成，一个栈帧对应一个方法，一个栈帧可能有多个OopMap

​		可以理解为 OopMap 就是商场的商品清单，清单上记录着每一种商品的所在位置和数量，通过清单可以直接到对应的货架上找到商品。

​		如果没有这份清单，需要寻找一件商品的时候，就只能从头开始，按顺序翻找每一个货架上的商品，直到找到对应的商品。

**这些对象引用间关系并非一成不变 ,如果每执行一条字节码指令都去生成一个OopMap那就必须消耗大量额外的储存空间，为了解决这个问题HotStop并没有让每条指令都生产OopMap，而是只在特定的位置生成OopMap，这个位置就被称为安全点**。。。。。。。。。。。。。



> OopMap 中存储了两种对象的引用：
>
> ◉ 栈里和寄存器内的引用
> 在即时编译中，在特定的位置记录下栈里和寄存器里哪些位置是引用
>
> ◉ 对象内的引用
> 类加载动作完成时，HotSpot 就会计算出对象内什么偏移量上是什么类型的数据
> 注：把存储单元的实际地址与其所在段的段地址之间的距离称为段内偏移，也称为有效地址或偏移量，因此，实际地址=所在段的起始地址+偏移量  

​		**safepoint即线程执行安全点，在垃圾回收的时候会stopword，而安全点检查的时候，如果有线程未抵达安全点，也会阻塞等待这些线程,具体看下面链接**

**具体看链接**

[JVM随笔 --- 安全点（safe point）与 安全区域（ safe region） - 知乎 (zhihu.com)]

https://zhuanlan.zhihu.com/p/461298916

[图解 OopMap、Safe Point、Safe Region - 知乎 (zhihu.com)]

https://zhuanlan.zhihu.com/p/441867302

### **4、深入理解java类加载机制**

https://blog.csdn.net/u011080472/article/details/51329315



### **5、理解JVM垃圾收集底层的 三色标记法详解，带“颜色”的JVM吗？**

## https://zhuanlan.zhihu.com/p/431406707

### **6、CMS垃圾收集器的并发更新失败是怎么回事（`promotion failed（晋升失败`）？如何优化？**

https://blog.csdn.net/Hmj050117/article/details/115415149

答：CMS老年代采用标记清除算法，空间清理后会有内存碎片，空间不连续，Survivor 区对象晋升老年代，空间一样也放不下就会造成并发更新失败问题

**优化办法：**
**让CMS在进行一定次数的Full GC（标记清除）的时候进行一次标记整理算法，**CMS提供了以下参数来控制：
-XX:UseCMSCompactAtFullCollection -XX:CMSFullGCBeforeCompaction=5
也就是CMS在进行5此Full GC（标记清除）之后进行一次标记整理算法，从而可以控制老年带的碎片在一定的数量以内，甚至可以配置CMS在每次Full GC的时候都进行内存的整理。

### **6.1、 concurrent mode failure（并发更新失败）**

这个错误是cms专有错误，并发清楚线程和工作线程同时工作，清理出来年老代的空间不足以存放由新生代晋升导年老代的对象

从而导致年老代垃圾回收变成了Serial Old，从而暂停应用程序，停顿时间过长

**优化：1.如晋升失败错误优化，还是采用在一定次数FULL GC（标记清除）后,进行一次标记整理算法**

-XX:UseCMSCompactAtFullCollection -XX:CMSFullGCBeforeCompaction=5

​			**2.优化空间比列，调整GC频率**

**注：一般还是空间碎片的问题** 

**总结一句话：使用标记整理清除碎片和提早进行CMS操作**

### **7、阿里高并发为什么推荐使用G1垃圾收集器**

答: 高并发很考验性能，并发执行任务追求低停顿响应,大吞吐量，在垃圾收集器里CMS，G1就比较符合要求;

参考：

https://developer.aliyun.com/article/1065982

https://blog.csdn.net/u011069294/article/details/108280100



CMS：

优点：在并发标记，并发清除的时候和用户线程并行，多线程处理工作任务，不需要stop the world(stw),交互性，程序用户体验良好

缺点：停顿时间不可控制，并发清除使用标记算法，会有空间碎片，会有晋升错误，concurrent mode failed 错误

G1是CMS的升级版().:**G1虽然也把内存分成了这三大类:E/S/O，G1把内存划分成很多小块（可以空间不连续逻辑上组成年轻年老代）, 每个小块会被标记为E/S/O中的一个，可以前面一个是Eden后面一个就变成Survivor了。(负责了年轻代与年老代的GC)**，**G1根据各个region里面的垃圾堆积的价值大小,回收所获得的空间大小以及回收所需时间的经验值，后台维护一个优先级列表，每次根据允许的收集时间，优先会有价值最大的region）**，只对达到要求的region进行GC,使用的是标记整理算法，停顿时间参数可控(**而G1每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如。 (阿里面试)**)，改良CMS的缺点！

最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。



### **8.线上系统GC问题如何快速定位与分析：**

答：

**jvm调优命令与调优工具**（https://blog.csdn.net/weixin_44688973/article/details/125793959）

## Arthas工具

### **9.阿里巴巴  Arthas 实现原理**

arthas 就是很好的一种，除了分析耗时，还可以打印调用栈、方法入参及返回，类加载情况，线程池状态，系统参数等等

其实现原理是解析 JVM 在操作系统中的文件，大部分操作是只读的，对服务进程没有侵入性，因此可以放心使用。

注：Arthas 是JVM的 AOP

https://www.cnblogs.com/cd4everyoung/p/15800333.html

### **10.单机几十万并发的系统JVM如何优化！**

https://www.jianshu.com/p/c0d740892d79

### **11.Volatile 底层的内存屏障是如何实现的？**

### https://mp.weixin.qq.com/s/uqVkA74v_WDeNKoj5M-A6A

### **12.MQSQL索引底层B+树结构与算法？**

https://blog.csdn.net/qq_33522097/article/details/126951762

### **13.聚集索引与覆盖索引与索引下推到底是什么？**

索引下推：https://baijiahao.baidu.com/s?id=1716515482593299829&wfr=spider&for=pc



### 聚簇索引，覆盖索引https://blog.csdn.net/ruanhao1203/article/details/98061034（其他百度）

### **14.请说说mysql的 buffpool机制？**

https://blog.csdn.net/devcloud/article/details/123788028



## **15.mysql事务，及底层实现原理**

答：mysql事务 acid

原理：undo log  redo log

https://www.cnblogs.com/cxscode/p/13656178.html

### **16.MVCC机制是如何保证事务的隔离性的**

答：MVCC多版本控制： 靠数据的隐藏字段 事务id  ,指向undolog日志的pointer

https://www.modb.pro/db/40241

https://www.sohu.com/a/494139983_121124376

https://baijiahao.baidu.com/s?id=1714820764902075184&wfr=spider&for=pc

### **17.超高并发使用事务时如何避免死锁**

https://www.cnblogs.com/ttaylor/p/15948018.html



### **18.对线上千万级大表加字段时，性能极慢问题如何处理？**



## 

### **19.高并发如何使用锁**

https://www.jianshu.com/p/a873e6f2ba0a

### **20.腾讯三面：进程写文件过程中，进程崩溃了，文件数据会丢吗**

答：https://mp.weixin.qq.com/s/8HgUoM1TEQkv5dpa0A_cnA



### **21.腾讯一面内存满了会发生什么？**

答：https://mp.weixin.qq.com/s/EsU9FT9D9K5Rt1BM0ySVmw



### **22、面试官：不同进程对应相同的虚拟地址，在 TLB 是如何区分的？**

答：https://mp.weixin.qq.com/s/ru-Y9NO-3dBaS__hWmgAEA



### **23、字节面：什么是伪共享？**

https://bit.ly/3LVspoH

### 24 、进程间通信-匿名管道、命名管道、消息队列、信号量、信号、socket

[凉了！张三同学没答好「进程间通信」，被面试官挂了.... (qq.com)](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247485318&idx=1&sn=0da0a684639106f548e9d4454fd49904&scene=21#wechat_redirect)





## 25、字节二面，优化HTTPS手段 (文下--------->图文网络 1.5)

https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247488081&idx=1&sn=a285752b4b1516830ba1f549323d3580&chksm=f98e56fbcef9dfedcfe006a920722a52bd865f0c1211ba8449cc55b32a7de2df1ddd88a25fb7&scene=178&cur_album_id=1337204681134751744#rd



## 26、字节一面，被问到的两个经典问题



https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247523583&idx=1&sn=5c5c5539fc0b071f3808b072ef5a2b06&chksm=f98dd855cefa514325494b8ab11cf156a2cadcd8b7cdb5cc8d5d19df5385b328fe0c1ef48154&scene=178&cur_album_id=1337204681134751744#rd



### 面试问点：

https://www.bilibili.com/read/cv11044026/

## 阿里金服十道经典面试

https://mp.weixin.qq.com/s/tEsSQYT6qjELdCrQLzMdFg



# **面试题汇总参考**

https://github.com/wuzhongzhi/bat













自我介绍：

​		面试官你好，我叫刘志锋，17年毕业从事互联网工作至今，从基础开发到参与架构研发设计，参与过优化型开发项目，从无至有研发型项目，及整体项目重构的项目，对it研发工作有着丰富经验，对其中技术体系能够快速认知辨析，加以灵活适用，我最近参与的工作是YUM(百盛餐饮)商城后台重构工作

整体架构  客户端接入DNS（httpdns）--->lvs(keepalive双主互备)---->nginx集群 ---->gateway网关（负载，熔断）------server集群（鉴权授权。。。。。。。。。。。。。。。。。。。）----数据库集群----------数据采集----kafuka数据缓冲----（es,hive,hbase）